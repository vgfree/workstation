### Linux 简明教程

[louis@louis workstation]$
第一个louis: 当前用户名	
第二个louis: 当前用户组	
第三个workstation : 当前目录名	


linux 文件类型: 目录/directory 文件/file
目录打开command : cd + dirname
文件打开command : vim + filename
示例:
```
cd /home
vim hello.c
```

linux文件与目录结构为树形结构
根目录: /  所有的文件都在根目录之下
家目录: ~  当前用户的目录 home
示例:
```
cd /home/ferrin/workstation
cd /
cd ~
```
ferrin为当前用户,那么ferrin就是当前用户的home目录

查看当前目录下的文件: ls
查看包括隐藏文件和目录: ls -ah
查看包括详细信息: ll

目录及文件创建
创建目录: mkdir + dirname
创建文件: touch + filename
创建并编辑文件: vim + filename

系统操作命令
关机: poweroff
重启: reboot

用户操作
切换到超级管理员root用户: su
切换到指定用户: su + username
退出当前用户: exit

### vim 简明教程
VIM 是什么意思?
vim其实是一款编辑器,可以把它理解为Linux环境下的Word软件,但是易用行和功能性要强
大的多!要想精通vim没有超大量的练习和较长时间的使用是不可能的,但是要想掌握vim的
日常用法却只需要10分钟就够了,10分钟就可以掌握80%的使用方法.
vim是一款软件,在windows下打开软件都是点击桌面快捷方式,但是在Linux中,快捷方式是
以命令/command的形式体现的,安装好软件后,只需要在命令行中输入并运行相应的命令就
可以启动软件!vim就是一个很好的例子.
启动软件示例:
`$ chrome` : 启动chrome浏览器
至于为什么会这样, 我们可以去/bin目录下去看一看,它包含了所有可执行的命令.
由此,我们可以更深入的来了解linux的内部结构

((( kernel内核 ) 操作系统+shell ) 用户层 )

内核是最核心的部分,所有的操作最终都要经过内核的处理,内核很小,只有几M大小,大约相
当于一首mp3的歌曲,它很紧凑,高效,提供各种功能,但是他却提供了最核心的功能,实现各
种功能需要和用户进行交互,那么就需要很多外围的代码扩充,外围代码就构成了操作系统,
(例如发动机最核心的就是做活塞运动的汽缸,但是同时需要和进油排气散热等部分一起组
 成真正的发动机),我们的常用软件属于用户层.但是shell比较特殊,linux是使用命令行
操作的,我们需要有一个程序能够输入并运行命令行,这个程序就是shell.

打开文件: vim + filename
打开后,页面下方会出现状态栏

`INSERT  linux_C简易教程.md[+]          markdown  93 words | 100% +  49:28 `

INSERT :表示vim当前状态为输入模式
linux_C简易教程.md : 表示当前操作的文件名
markdown : 表示文件类型
93 words : 表示当前文件总字数
100% : 当前光标在全文中的位置百分数
49:28 : 当前光标在第49 行 第28 列 字符处

vim模式
需要注意的就是 INSERT/输入 和 NOMAL/普通 模式
切换为INSERT按'i',切换为NOMAL按'Esc'
INSERT 模式: 可以进行增删改查等操作
NOMAL 模式: Shift + : 可以将左下角状态栏输入模式激活
此时, ":w" 保存但不退出, ":q" 退出但不保存, ":wq" 保存并退出
加上"!"表示强制执行

### C语言简明教程
用实例说话:
打印日期程序 date.c
```C++
#include <stdio.h>	// 头文件

int main()		// 主函数
{
	int month = 5;	// 声明变量并赋值
	int day;	// 声明变量
	day = 10;	// 对变量进行赋值

	printf("今天的日期是: %d 月 %d 日\n", month, day);	// 格式化输出

	return 0;	// 返回值
}

/*
头文件: 封装了很多我们常用的函数,在函数体中我们可以直接使用声明了头文件的函数,
	而不需要重新去写函数是如何实现的,如printf, 我们也可以自己封装头文件
主函数: 任何一个C程序都有main 函数,它是一个函数的执行入口,并且函数都有返回值,
	int 表示返回值为int类型,此处对应了return 0
声明变量: 可以在声明时赋值,也可以先声明再赋值,此处'='表示将右边的值5赋给左边的
	变量 month.在C中,通常意义上的'等于'概念我们需要使用'=='
格式化输出: 输出到终端terminal,输出内容为""中的内容,%d表示格式化符号,我们需要将
	month和day的值格式化到输出语句中,他们都是int型,所以使用"%d",以后遇到其
	它类型时使用不同的格式化符号
返回值: 函数执行成功后返回给调用函数的值,通常是0

Warning: 注意符号对应的输入法
	每一句都以';'结尾
	括号/引号都是成对出现的
	单行注释用'// 注释'
	多行注释用'/* 注释 */'
*/
```

程序编译:
程序为什么需要编译?
首先要从最底层说起,任何一个程序的执行,最终都是要被机器去执行,而机器只能识别二
进制的0和1,所以最底层的机器语言就是0和1,例如一个简单的复制操作,就是由很多个01
组成的机器语言指令去执行,如果去记住这些01组成的代码,简直是要命!最早期的程序员
真的需要去记住,很痛苦,所以人们发明了汇编语言,我们可以用一条指令例如"MOV" 代表
几十位执行复制操作的机器码,所以汇编语言只是机器语言的助记符,虽然相对于机器语言有
了很大的进步,但是依然很难学习,因为纯逻辑上的思路和正常人的思路差别很大,难以学
习.汇编和机器语言都是低级语言,而C语言的出现就是为了解决此类问题,C语言进一步进行
了逻辑封装,一行C语言代码的背后封装了很多条具体去实现的汇编语言.我们可以这样理解
汇编和机器语言就像是做菜的过程中具体的洗菜,炒菜等过程,而C语言就直接一句"炒青菜",
我们并不是省略了具体的操作过程,而是将具体的操作过程进行了逻辑封装,便于学习和使
用.
我们现在再来说程序的编译.写好的C程序并不能直接驱动机器跑起来,我们需要一个"翻译
器",将C语言翻译成汇编语言,再翻译成机器语言,这个翻译器就是我们用的 GCC编译器 .
GCC编译器在编译过程中会将C语言翻译为汇编语言,同时,我们在上面的例子中看到printf
是包含在头文件中,我们可以直接使用它,那么编译器也会将头文件包含的具体内容包含进
来,总之,就是将C语言程序编译为可直接执行的二进制文件.编译后默认生成a.out文件,就
是这样的二进制文件.我们可以直接运行.

编译程序: gcc + 程序名
`gcc date.c`

执行可执行文件: ./可执行程序名
'./a.out'

思考: 为什么可以直接执行gcc ?

说点题外话,C语言相对于汇编来说已经有了很大的进步了,但是很多人觉得C还是太麻烦了
什么都得自己写,烦死了,于是就有人不断地开发出来了更多的高级语言,它们对操作进行了
更好的封装,学起来更简单,但是一个不容忽视的问题是,这些语言的执行效率和C比起来相
差很大,例如脚本语言Python,用来开发很适合,开发效率很高,一个人用Python写代码的效率
比用C要高好几倍,但是执行效率相对于C要低好几十倍,所以不同的语言有自己不同的适用
场景,一般涉及硬件,系统级别的开发,都会依赖于C,这将获得很高的执行效率,但是其他方
面的开发就会依赖于其他更加便于开发,执行效率又过的去的计算机语言,例如Java等

循环判断语句:
循环语句:
计算1+2+3...100
如果按照正常的方法来算,算死你,换成加到10000怎么办?
```C++
#include <stdio.h>
int main()
{
	int i;
	int sum = 0;

	for (i = 0; i <= 100; i++)	// i++表示每执行一次i的值+1
	{
		sum = sum + i;
	}

	printf("sum = %d \n", sum);

	return 0;
}
```
这个循环语句是如何实现的?我们来分析一下for循环
```
for(表达式1; 表达式2; 表达式3)
{
	函数体
}
```
					---------------<----------------
					!				|
执行顺序: 表达式1执行 --> 表达式2判断是否成立?  -成立-> 执行函数体 --> 执行表达式3
					|
					--> 结束循环

判断语句:
判断a和b的大小,输出大的数
```C++
#include <strdio.h>
int main()
{
	int a = 10;
	int b = 20;

	if (a > b)
	{
		printf("a = %d is bigger!\n", a);
	}
	else if (a < b)
	{
		printf("b = %d is bigger!\n", b);
	}
	else
	{
		printf("a == b !\n");
	}

	return 0;
}
```
if条件判断语句
if ... else if ... else ...
if ... else ...
if ...

练习:
1. 计算1+2+...+1000
2. 计算1+3+5+...+99
3. 计算2+4+6+...+1000
4. 计算1+2+3+...+10000000

5. 输入一个数,判断它是奇数还是偶数
6. 输出1~100中所有能被3整除的数
7. 写一个程序能够判断闰年

第5题计算的结果很诡异,答案是负数,这是为什么?我们暂且不讨论之所以为负数的原因,单
从结果来看,这肯定是不正确的,原因是什么呢?
此次相加的结果一定是一个很大的数,有没有可能是因为这个数的范围超出了int整型数的
取值范围,导致表达错误呢?int型数,使用4个字节来表示.什么是字节?计算机最底层使用01
来表示,我们将8个01位表示一个字节/Byte,那么int整型数就有4Byte,也即是32个01位,能
表达的数字范围为0 ~ 2^32, 即最大数为4 294 967 295, 这个数字没有所计算的值大,那么
就会产生数据溢出.表达出现错误.
遇到这种情况我们就需要考虑更大范围的数据类型了, 例如 long 类型,试着将 sum 的数
据类型换作 long , 注意格式化打印时要改作 %ld , 再看计算结果.

类似的,我们以上使用的都还是整数类型,遇到小数怎么办?
float : 单精度类型 对应打印为 %f
double: 双精度类型 对应打印为 %lf
其他的一些有关格式化输出和数据类型的方法自己看一看视频和书,做做练习试一试.

二进制/八进制/十六进制:
这是个很烦又绕不开,学完觉得也就这样的知识.
二进制:
数字: 0 1
示例: 110
十进制大小: `1*10^2 + 1*10^1 + 0*10^0 = 110`
二进制大小: `1*2^2 + 1*2^1 + 0*2^0 = 6`

八进制:
数字: 0 1 2 3 4 5 6 7
示例: 110
八进制大小: `1*8^2 + 1*8^1 + 0*8^0 = 72`
二进制表示法: 001 001 000

十六进制:
数字: 0 1 2 3 4 5 6 7 8 9 A B C D E F
示例: 110
十六进制大小: `1*16^2 + 1*16^1 + 0*16^0 = 272`
二进制表示法: 0001 0001 0000

所以,任何一个数用不同的进制来解析,会得到截然不同的结果.
熟悉以上的唯一办法就是多做练习,做尽量多的练习,做多了看多了,自然就不陌生了.


